[{"content":"前言 统一配置：就是将所有的配置信息都以文本的格式存放在git里面，可以随时查看修改记录，以此来帮助我们比较不同配置的差异性，在此基础上不断更新迭代。\n需要使用Ruby工具链来为整个项目搭建一致的开发环境和构建环境。\n为什么选择Ruby呢？因为目前流行的第三方工具CocoaPods和fastlane都是Ruby开发的，并且Ruby有成熟的依赖库管理工具RubyGems和Bundler，其中Bundler可以帮我们有效管理CocoaPods和fastlane的版本。\nRuby版本控制 Homebrew安装命令（如果电脑已经安装过的，请忽略）\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)\u0026#34; ruby环境管理工具rbenv安装（如果电脑已经安装过的，请忽略）\n1 brew install rbenv ruby-build rbenv-vars rbenv安装好之后，需要将下面的设置添加到你的Shell配置文件里，比如~/.bash_profile或者~/.zshrc或者~/.zprofile文件 这样就能保证每次打开终端的时候都会初始化rbenv\n1 2 3 # rbenv export PATH=\u0026#34;$HOME/.rbenv/bin:$PATH\u0026#34; eval \u0026#34;$(rbenv init -)\u0026#34; 为项目指定ruby环境版本\n1 2 3 $ cd $(PROJECT_DIR) $ rbenv install 2.7.1 $ rbenv local 2.7.1 Gem版本管理Bundle 为项目初始化bundle环境\n1 2 cd $(PROJECT_DIR) bundle init 修改Gemfile添加需要的gem包，比如fastlane\n1 gem \u0026#39;fastlane\u0026#39;, \u0026#39;~\u0026gt; 2.219\u0026#39; 安装Gemfile上所有的Gem包: Gem资源网站\n1 bundle install 为项目添加fastlane初始化\n1 bundle exec fastlane init 设置环境变量fastlane才能正常运行，特别是语言环境未设置UTF-8，将会导致构建和上传构建时出现问题\n在**~/.bashrc**、 /.bash_profile、 ~/.profile 或 ~/.zshrc 根据你电脑对应的bash命令配置文件添加：\n1 2 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 运行fastlane的lane\n1 bundle exec fastlane lane名称 fastlane 命令格式：fastlane **XXX**\nfastfile 中的 lane 自定义action 自定义plugin lane可以调用其他的lane，也可以调用action\n但是action是最小执行单元，不能调用其他的lane，也不能调用其他的action**\n自定义lane my_lane.rb文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 自定义fastlane的lane # options 是传入的参数 # 也可以这么写 lane(:my_lane) do |options| lane :my_lane do |options| # 这个可以打印 UI.success \u0026#34;自定义的lane\u0026#34;.yellow # 这个也可以打印 puts \u0026#34;自定义的lane\u0026#34;.blue # 工作目录：/Users/liven/Documents/Cash/fastlane # 打印当前的目录 puts \u0026#34;[my_lane] #{Dir.pwd}\u0026#34; # 切换到上一级目录 Dir.chdir(\u0026#34;..\u0026#34;) do # /Users/liven/Documents/Cash puts \u0026#34;[my_lane] #{Dir.pwd}\u0026#34; end end Fastfile文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 default_platform(:ios) # 如果要调用其他文件的lane，必须要要import # 注意这里要写完整的文件名，包括后缀 import \u0026#39;my_lane.rb\u0026#39; platform :ios do desc \u0026#34;Description of what the lane does\u0026#34; lane :custom_lane do # 在另外一个文件my_lane.rb中定义了lane # lane可以嵌套使用 my_lane end end 自定义action 通过终端的方式创建新的Action\n1 2 3 4 # 第一步： bundle exec fastlane new_action # 第二步： # 根据提示输入action的名称就可以了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 module Fastlane module Actions class MyActionAction \u0026lt; Action # 1. 执行的方法 def self.run(params) name = parames[:name] age = parames[:age] # fastlane will take care of reading in the parameter and fetching the environment variable: UI.message(\u0026#34;Parameter API Token: #{name} #{age}\u0026#34;) end def self.description \u0026#39;A short description with \u0026lt;= 80 characters of what this action does\u0026#39; end def self.details \u0026#39;You can use this action to do cool things...\u0026#39; end # 2. 接受的参数 def self.available_options # Define all options your action supports. # Below a few examples [ FastlaneCore::ConfigItem.new(key: :age, description: \u0026#39;API Token for MyActionAction\u0026#39;), FastlaneCore::ConfigItem.new(key: :name, description: \u0026#39;Create a development certificate instead of a distribution one\u0026#39;) ] end def self.output # Define the shared values you are going to provide # Example [ [\u0026#39;MY_ACTION_CUSTOM_VALUE\u0026#39;, \u0026#39;A description of what this value contains\u0026#39;] ] end def self.return_value # If your method provides a return value, you can describe here what it does end def self.authors # So no one will ever forget your contribution to fastlane :) You are awesome btw! [\u0026#39;Your GitHub/Twitter Name\u0026#39;] end def self.is_supported?(platform) # you can do things like # # true # # platform == :ios # # [:ios, :mac].include?(platform) # platform == :ios end end end end action的调用，不需要导入自定义action的文件\n1 2 3 4 5 6 7 8 platform :ios do desc \u0026#34;Description of what the lane does\u0026#34; lane :custom_lane do # 调用自定义的action # action的名字就是文件名，不需要后缀 my_action(name: \u0026#34;zhansan\u0026#34;, age: \u0026#34;18\u0026#34;) end end 命令行执行action\n1 bundle exec fastlane run my_action name:\u0026#39;zhansan\u0026#39; age:18 fastlane 和 action 的工作目录的區別 1 2 3 4 5 # fastlane的工作目录 # /Users/liven/Documents/Cash/fastlane # action的工作目錄 # /Users/liven/Documents/Cash lane的最后一行自动作为返回值 1 2 3 4 5 6 7 8 9 10 11 lane :my_lane1 do # 打印结果是： 4 puts my_lan2 end lane :my_lane2 do 1 2 3 x = 4 end lane_context 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 lane :lane1 do # 哈希值 # {:DEFAULT_PLATFORM=\u0026gt;:ios, :PLATFORM_NAME=\u0026gt;:ios, :LANE_NAME=\u0026gt;\u0026#34;my_lane\u0026#34;} puts lane_context # 新增一个my_name值 lane_context[:my_name] = \u0026#39;zhansan\u0026#39; # 调用lane2 lane2 end lane :lane2 do # 取出my_lane的值： zhansan puts lane_context[:my_lane] end 炫技写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 定一个module module MyModule # 还可以是嵌套 module Login MY_NAME = :my_name end end lane :lane1 do lane_context[MyModule::Login::MY_NAME] = \u0026#39;zhansan\u0026#39; lane2 end lane :lane2 do puts lane_context[MyModule::Login::MY_NAME] end action中如何使用lane_context 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 module Fastlane module Actions # 通过moudle定义共享的变量 module SharedValues MY_NAME = :MY_NAME MY_AGE = :MY_AGE end class ContextAction \u0026lt; Action def self.run(params) # 使用lane_context Actions.lane_context[Actions::SharedValues::MY_NAME] = \u0026#34;zhansan\u0026#34; Actions.lane_context[Actions::SharedValues::MY_AGE] = \u0026#34;18\u0026#34; end end end end 终止lane的执行 lane的终止关键字不是return，而是next\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 lane :lane1 do puts \u0026#39;2\u0026#39; * 20 next puts \u0026#39;3\u0026#39; * 20 end lane :lane2 do puts \u0026#39;1\u0026#39; * 20 lane1 puts \u0026#39;4\u0026#39; * 20 end # 最后打印的结果 # 1 # 2 # 4 private_lane 1 2 3 # private_lane定义的lane只能是在lane之间调用，不能在外部调用，比如在终端直接调用 private_lane :lane1 do end lane hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 before_all do |lane, options| # 所有lane开始前会回掉 UI.message(\u0026#34;------------------ [before_all] #{lane} #{lane.class}\u0026#34;) end before_each do |lane, options| # 每一个lane执行之前回回调 end after_all do |lane, options| # 所有lane执行完之后会回掉 end after_each do |lane, options| # 每一个lane执行之后回回调 end error do |lane, exception, options| # lane执行报错的回调 if options[:debug] puts \u0026#34;hi: )\u0026#34; end end 通过send调用lane 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private_lane :pipeline_prepare do |options| puts \u0026#34;pipeline_prepare: #{options}\u0026#34;.blue end private_lane :pipeline_doing do |options| puts \u0026#34;pipeline_doing: #{options}\u0026#34;.blue end private_lane :pipeline_finish do |options| puts \u0026#34;pipeline_finish: #{options}\u0026#34;.blue end lane :pipeline do |options| state = options[:state] send(\u0026#34;pipeline_#{state}\u0026#34;.to_sym, options) end 设置环境变量 方式一：\n1 2 # 在Fastlife文件中直接设置 ENV[\u0026#34;FASTLANE_PLATFORM_NAME\u0026#34;] = \u0026#39;iOS\u0026#39; 方式二：\n1 2 3 4 # 在终端命令中，export 导出 定义好的 环境变量 # 为了避免不和其他的常量冲突 # 建议添加一个“FASTLANE”前缀 export NAME=\u0026#39;zhansan\u0026#39; 方式三：\n1 2 3 4 5 # 通过第三方库：dotenv # 1. 在 gemfile文件中添加dotenv # 2. 在fastlane的根目录下创建 .env 文件 # 3. 直接在.env文件中定义key value # 4. 通过EVN[\u0026#34;key\u0026#34;]就能读取 调用外部命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 lane :hello do # 1. # 通过Actions.sh执行的命令会将‘命令的标准输出’赋值给output变量 output = Actions.sh(\u0026#34;ls -l\u0026#34;) puts \u0026#34;output:\u0026#34; puts output # 2. # 通过system执行的命令，只返回true或false的值 puts system(\u0026#34;ls -l\u0026#34;) # 3. # 通过反引号执行命令，结果跟Actions.sh 一样 pod_cmd = `ls -l` # 4. output = sh(\u0026#34;ls -l\u0026#34;) puts \u0026#34;output:\u0026#34; puts output end 拼接命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 使用 ‘ ’ 拼接 cmds = [] cmds \u0026lt;\u0026lt; \u0026#34;ls\u0026#34; cmds \u0026lt;\u0026lt; \u0026#34;-l\u0026#34; Actions.sh(cmds.join(\u0026#39;\u0026#39;)) # 2. 使用 \u0026#39;;\u0026#39; 拼接 cmds = [] cmds \u0026lt;\u0026lt; \u0026#34;cd $HOME\u0026#34; cmds \u0026lt;\u0026lt; \u0026#34;ls -l\u0026#34; Actions.sh(cmds.join(\u0026#39;;\u0026#39;)); # 3. 使用 ‘\u0026amp;\u0026amp;’ 拼接 # 这个与第二个的不同是，如果前面的命令报错了，那么后面的命令不会再执行 cmds = [] cmds \u0026lt;\u0026lt; \u0026#34;cd XXX\u0026#34; cmds \u0026lt;\u0026lt; \u0026#34;ls -l\u0026#34; Action.sh(cmds.join(\u0026#39;\u0026amp;\u0026amp;\u0026#39;)) Action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 lane :hello do # 创建callback闭包的方式 # 1. 通过lambda定义一个闭包 callback = lambda do |result| puts result end # 2. Proc callback = Proc.new do |result| puts result end # 3. 推荐 callback = -\u0026gt;(result) { puts result } # 调用指定的action，传入callback git_clone(callback: callback) end 1 2 3 4 5 def self.run(params) callback = params[:callback] # if callback如果有callback的话才调用 callback.call([\u0026#39;11\u0026#39;, \u0026#39;22\u0026#39;]) if callback end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def self.available_options # Define all options your action supports. # Below a few examples [ # string FastlaneCore::ConfigItem.new( key: :age, # 调用的时候的参数名 env_name: \u0026#39;FL_MY_ACTION_AGE\u0026#39;, # 也可以从环境变量中获取，如果不需要从环境量获取，可以删除 description: \u0026#39;API Token for MyActionAction\u0026#39;, type: String, # 值的类型，可以不写，默认是string optional: false), # 是否是必须的，默认是true # boolean FastlaneCore::ConfigItem.new( key: :hidden, type: Boolean, defaultVale: false, description: \u0026#39;Create a development certificate instead of a distribution one\u0026#39;), # array FastlaneCore::ConfigItem.new( key: :files, type: Array, optional: false, description: \u0026#39;Create a development certificate instead of a distribution one\u0026#39;), # 多态类型的参数(可以接受多种类型的参数) FastlaneCore::ConfigItem.new( key: :files, is_string: false, #通过这个参数设置为false，来指定为多态的参数 verify_block: -\u0026gt;(value) { verify_option(value) }), #对参数进行校验, 比如说我只希望接受 string，Array，Hash的参数，其他类型的就会报错 # Proc(代码块) FastlaneCore::ConfigItem.new( key: :callback, type: Proc, optional: true), # 互斥参数（只能传其中一个，都传会报错） FastlaneCore::ConfigItem.new( key: :arg1, type: String, optional: true, conflicting_options: [:arg2]), FastlaneCore::ConfigItem.new( key: :arg2, type: String, optional: true, conflicting_options: [:arg1]), ] end def self.verify_option(value) case value when String @@polymophic_option = value when Array @@polymophic_option = value.join(\u0026#34; \u0026#34;) when Hash @@polymophic_option = value.to_s else UI.user_error! \u0026#34;Invalid option: #{value.inspect}\u0026#34; end end ","date":"2024-02-04T06:47:17+08:00","permalink":"https://livenbom.github.io/p/cicd-01/","title":"CICD 01"},{"content":"p12 文件 也叫做p12证书，本身就是一个加密的证书，后缀是.p12。\n在创建CSR（Certificate Signing Request，证书签名请求）的时候，会同时创建一对私钥和公钥保存在Mac电脑上。 而CSR中包含公钥、您的标识信息（如您的组织名称、常用名、电子邮件地址）以及一个数字签名。这个数字签名是使用刚刚生成的私钥对上述信息的哈希值进行签名得到的。\n登录apple developer 网站，点击新建证书，然后上传在Mac电脑创建的CSR文件，完成之后下载到本地，双击下载的development.cer证书安装，\n最后就能在keychain中看到创建CSR时同时自动创建的私钥绑定了一个对应的Cer证书了\n关于CSR上传到Apple Developer CA之后的验证和生成：\n验证请求信息：CA首先验证CSR中提供的信息，确保它满足颁发证书的要求 使用私钥创建证书：验证通过之后，CA会使用其自己的私钥对您的公钥（及其他信息）进行签名，生成一个数字证书。 生成的CER证书包含的信息：\n持有者的公钥：这是证书的核心部分，即您在CSR中提交的公钥 持有者的身份信息：包括您在CSR中提供的信息，如组织名、通用名等 颁发者的身份信息：Apple证书颁发机构的信息 有效期：证书的有效起始日期和过期日期 证书序列号：CA 分配的唯一序列号，用于证书的识别 数字签名：CA 对上述所有信息的签名，用于验证证书的真实性和完整性 原理流程图： 关键点：私钥对什么信息加密。\n这个加密的信息就是我们要最终要验证的。\n这里有两个私钥：\n第一个是：保存在我们电脑端的私钥M（创建的时机是在创建CSR的时候就同时创建了）\n私钥M是给App加密，那么要验证App的完整性就是必须保证公钥，所以会将CSR文件上传到Apple CA中，用苹果的私钥签名 第二个是：苹果服务器上的私钥A\nAppStore 提交到AppStore的应用会被Apple重新签名，不再使用开发者的证书和描述文件。因此一旦应用通过审核并发布到AppStore上，它不再依赖于您最初用于签名的证书和描述文件。\n证书和描述文件的过期或废除对应用的影响 已发布的应用： 过期或废除证书或描述文件，不会有影响 更新应用：如果您的证书过期或被废除，影响的是您提交新应用或更新现有应用到AppStore的能力。需要确保有效的证书签名应用，才能提交新的版本 开发和测试：对应开发和测试阶段，如果描述文件或者开发者证书过期或废除，会直接影响到您在设备上的安装和打开。在这种情况下，您需要重新生成并下载新的证书和描述文件，然后在Xcode中更新这些设置 ","date":"2024-02-02T08:15:41+08:00","permalink":"https://livenbom.github.io/p/ios-certification/","title":"IOS Certification"},{"content":"相关文章推荐阅读顺序： alignment-layout\nframe-behaviors\n","date":"2024-01-27T09:37:26+08:00","permalink":"https://livenbom.github.io/p/swiftuilayout/","title":"SwiftUILayout"},{"content":"原文：SwiftLee, 本文主要是自己做记录便于后续的查找\nhttps://www.avanderlee.com/wp-content/uploads/2022/02/debug_swiftui_view_animation.mp4\n","date":"2024-01-25T10:02:26+08:00","permalink":"https://livenbom.github.io/p/debugswiftui/","title":"DebugSwiftUI"},{"content":"SwiftUI中如何优雅创建条件式修饰符 在一些小的需求，我们可以会通过if语句这么写，比如\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct ContentView: View { var body: some View { if #available(iOS 14.0, *) { Text(\u0026#34;Hello, world!\u0026#34;) .padding() } else { /// iOS 13 only Text(\u0026#34;Hello, world!\u0026#34;) .background(Color.red) // Apply a red color .padding() } } } 虽然看着没什么问题，但是如果一个View的modifier多了，那么都需要复制一遍，在维护和可读性造成了很大的挑战\n第一次尝试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 extension View { /// Applies the given transform if the given condition evaluates to `true`. /// - Parameters: /// - condition: The condition to evaluate. /// - transform: The transform to apply to the source `View`. /// - Returns: Either the original `View` or the modified `View` if the condition is `true`. @ViewBuilder func `if`\u0026lt;Content: View\u0026gt;(_ condition: Bool, transform: (Self) -\u0026gt; Content) -\u0026gt; some View { if condition { transform(self) } else { self } } } 改造后：\n缺点：需要在每个要用到版本判断的View，添加一个shouldApplyBackground计算属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct ContentView: View { private var shouldApplyBackground: Bool { guard #available(iOS 14, *) else { return true } return false } var body: some View { Text(\u0026#34;Hello, world!\u0026#34;) .padding() .if(shouldApplyBackground) { view in // We only apply this background color if shouldApplyBackground is true view.background(Color.red) } } } 第二次尝试：@autoclosure 1 2 3 4 5 6 7 8 9 10 11 12 13 14 extension View { /// Applies the given transform if the given condition evaluates to `true`. /// - Parameters: /// - condition: The condition to evaluate. /// - transform: The transform to apply to the source `View`. /// - Returns: Either the original `View` or the modified `View` if the condition is `true`. @ViewBuilder func `if`\u0026lt;Content: View\u0026gt;(_ condition: @autoclosure () -\u0026gt; Bool, transform: (Self) -\u0026gt; Content) -\u0026gt; some View { if condition() { transform(self) } else { self } } } 改造后：\n缺点：虽然通过一个闭包的方式，可以消除创建计算属性的问题，但是同时有两个block，会造成可读性不好，而且这个版本判断也会在多个需要用到的地方重复写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ContentView: View { var body: some View { Text(\u0026#34;Hello, world!\u0026#34;) .padding() .if({ if #available(iOS 14, *) { return true } return false }()) { view in view.background(Color.red) } } } 第三次尝试（最终） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 extension View { /// Applies the given transform if the given condition evaluates to `true`. /// - Parameters: /// - condition: The condition to evaluate. /// - transform: The transform to apply to the source `View`. /// - Returns: Either the original `View` or the modified `View` if the condition is `true`. @ViewBuilder func `if`\u0026lt;Content: View\u0026gt;(_ condition: Bool, transform: (Self) -\u0026gt; Content) -\u0026gt; some View { if condition { transform(self) } else { self } } } extension Bool { static var iOS13: Bool { guard #available(iOS 14, *) else { // It\u0026#39;s iOS 13 so return true. return true } // It\u0026#39;s iOS 14 so return false. return false } } 改造后：\n1 2 3 4 5 6 7 8 9 struct ContentView: View { var body: some View { Text(\u0026#34;Hello, world!\u0026#34;) .padding() .if(.iOS13) { view in view.background(Color.red) } } } ","date":"2024-01-23T21:47:55+08:00","permalink":"https://livenbom.github.io/p/swiftui-conditional-modifier/","title":"SwiftUI Conditional Modifier"},{"content":"Match 的原理及使用： https://juejin.cn/post/6844903619393765389\n1 2 cd [项目根目录] bundle exec fastlane match init ","date":"0001-01-01T00:00:00Z","permalink":"https://livenbom.github.io/p/","title":""}]